"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[1086],{5476:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var o=t(4848),i=t(8453);const a={sidebar_position:2},s="Providing ViewModels to your Screens",r={id:"common-use-cases/providing-viewmodels",title:"Providing ViewModels to your Screens",description:"Getting a ViewModel specific to one Screen",source:"@site/docs/common-use-cases/providing-viewmodels.md",sourceDirName:"common-use-cases",slug:"/common-use-cases/providing-viewmodels",permalink:"/v2/common-use-cases/providing-viewmodels",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/common-use-cases/providing-viewmodels.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Bottom bar navigation",permalink:"/v2/common-use-cases/bottom-bar-navigation"}},l={},d=[{value:"Getting a ViewModel specific to one Screen",id:"getting-a-viewmodel-specific-to-one-screen",level:2},{value:"Using default parameters feature",id:"using-default-parameters-feature",level:3},{value:"Using a setup Composable",id:"using-a-setup-composable",level:3},{value:"Using <code>dependenciesContainerBuilder</code>",id:"using-dependenciescontainerbuilder",level:3},{value:"Manually calling your screen Composable",id:"manually-calling-your-screen-composable",level:3},{value:"Share ViewModels between multiple destinations",id:"share-viewmodels-between-multiple-destinations",level:2},{value:"Make your one liner ViewModel getter",id:"make-your-one-liner-viewmodel-getter",level:2},{value:"Manual or no dependency injection",id:"manual-or-no-dependency-injection",level:3},{value:"Other DI frameworks",id:"other-di-frameworks",level:3}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"providing-viewmodels-to-your-screens",children:"Providing ViewModels to your Screens"}),"\n",(0,o.jsx)(n.h2,{id:"getting-a-viewmodel-specific-to-one-screen",children:"Getting a ViewModel specific to one Screen"}),"\n",(0,o.jsxs)(n.p,{children:["Android Architecture Components ViewModel is a useful class that can easily be tied to a ",(0,o.jsx)(n.code,{children:"NavBackStackEntry"}),". This means that the state of your screen is alive while that screen is in the back stack. If the user goes back to that screen, you don't need to do anything extra: the previous state will still be there."]}),"\n",(0,o.jsxs)(n.p,{children:["Even though Compose Destinations will call your annotated Composables with a limited set of components it can provide out the box (read about them ",(0,o.jsx)(n.a,{href:"../arguments/nav-host-parameters",children:"here"}),"), there are a few ways you can get the ViewModel."]}),"\n",(0,o.jsx)(n.admonition,{type:"important",children:(0,o.jsxs)(n.p,{children:["In these next examples, I'll be using ",(0,o.jsx)(n.code,{children:"hiltViewModel()"})," function to get the ViewModel.\nIf you're not using Hilt, then check the ",(0,o.jsx)(n.a,{href:"#make-your-one-liner-viewmodel-getter",children:"last section of this page"})," for a way to make your own one-liner function to replace ",(0,o.jsx)(n.code,{children:"hiltViewModel()"})," with."]})}),"\n",(0,o.jsx)(n.h3,{id:"using-default-parameters-feature",children:"Using default parameters feature"}),"\n",(0,o.jsx)(n.p,{children:"This is probably the most simple approach if you have a simple function you can call in a Composable scope to get a ViewModel."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>\n@Composable\nfun MyScreen(\n    viewModel: MyScreenViewModel = hiltViewModel()\n) { /*...*/ }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"using-a-setup-composable",children:"Using a setup Composable"}),"\n",(0,o.jsx)(n.p,{children:'A setup Composable is a place to get all state and "event handlers" and then call the Composable that will compose the actual screen content and can just receive state and lambdas.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>\n@Composable\nfun MyScreen() {\n    val viewModel: MyScreenViewModel = hiltViewModel()\n    \n    MyScreenContent(\n        isButtonEnabled = viewModel.isButtonEnabled, // example of state\n        onButtonClick = viewModel::onButtonClicked // example of events\n    )\n}\n\n\n@Composable\nfun MyScreenContent(\n    isButtonEnabled: Boolean,\n    onButtonClick: () -> Unit\n) { /*...*/ }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If you're used to Jetpack Compose navigation, think of this method as you would think about the setup code you would do inside ",(0,o.jsx)(n.code,{children:"NavGraphBuilder"}),'. With Compose Destinations, whatever you\'d do there, you can do in this "setup" Composable.']}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:['Notice how the "Content" function is a "pure" Composable.',(0,o.jsx)(n.br,{}),"\n","It only takes stuff that doesn't depend on the platform, it could even be part of a module shared in Kotlin Multiplatform.",(0,o.jsx)(n.br,{}),"\n","Of course, you can accomplish the same thing with any of the other approaches."]})}),"\n",(0,o.jsxs)(n.h3,{id:"using-dependenciescontainerbuilder",children:["Using ",(0,o.jsx)(n.code,{children:"dependenciesContainerBuilder"})]}),"\n",(0,o.jsx)(n.p,{children:"Even though this method is usually more appropriate to prepare dependencies which will be used by multiple/all screens, you can still use it for this case:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"DestinationsNavHost(\n    dependenciesContainerBuilder = { //this: DependenciesContainerBuilder<*>\n        destination(MyScreenDestination) {\n            dependency(hiltViewModel<MyScreenViewModel>()) \n        }\n    }\n)\n"})}),"\n",(0,o.jsx)(n.p,{children:"And then:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"@Destination<RootGraph>\n@Composable\nfun MyScreen(\n    viewModel: MyScreenViewModel // <-- this will be provided by the lib through the `dependenciesContainerBuilder`\n)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"manually-calling-your-screen-composable",children:"Manually calling your screen Composable"}),"\n",(0,o.jsx)(n.p,{children:"This is the closest way to how you'd do it with Jetpack Compose Navigation. But with Compose Destinations the only thing you're doing is calling the Composable. No navigation arguments or navigation graphs declaration done in the same place:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"DestinationsNavHost(\n    //...\n) {\n    composable(MyScreenDestination) { //this: DestinationScope<MyScreenDestination.NavArgs>\n        MyScreen(\n            viewModel = hiltViewModel()\n        )\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In contrast to if you were using Jetpack Compose Navigation, you are not building the navigation graph here (that information comes through the ",(0,o.jsx)(n.code,{children:"navGraph"})," parameter). So you don't need to do this for all your screens, just the ones that need some parameters that the library cannot provide."]}),"\n",(0,o.jsx)(n.h2,{id:"share-viewmodels-between-multiple-destinations",children:"Share ViewModels between multiple destinations"}),"\n",(0,o.jsx)(n.p,{children:"If you want to share a ViewModel with multiple destinations, you need to choose a scope that lives longer than a specific screen. Usually that will be either a nested navigation graph if you want to share a ViewModel with all destinations that belong to that nested nav graph, or an Activity if you want to share a ViewModel with all your destinations."}),"\n",(0,o.jsxs)(n.p,{children:["Either way, in this case, the simplest option (even though the above ones can also work) is to use ",(0,o.jsx)(n.code,{children:"dependenciesContainerBuilder"})," of ",(0,o.jsx)(n.code,{children:"DestinationsNavHost"})," function.\nHere is what that looks like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'@Composable\nfun AppNavigation(\n    activity: ComponentActivity\n) {\n    val destinationsNavigator = navController.rememberDestinationsNavigator()\n    DestinationsNavHost(\n        //...\n        dependenciesContainerBuilder = { //this: DependenciesContainerBuilder<*>\n\n            // \ud83d\udc47 To tie SettingsViewModel to "settings" nested navigation graph, \n            // making it available to all screens that belong to it\n            navGraph(NavGraphs.settings) {\n                val parentEntry = remember(navBackStackEntry) {\n                    destinationsNavigator.getBackStackEntry(NavGraphs.settings)\n                }\n                dependency(hiltViewModel<SettingsViewModel>(parentEntry))\n            }\n\n            // \ud83d\udc47 To tie ActivityViewModel to the activity, making it available to all destinations\n            dependency(hiltViewModel<ActivityViewModel>(activity))\n        }\n    )\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Then a screen that belongs to ",(0,o.jsx)(n.code,{children:"SettingsGraph"})," navigation graph could just do:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"@Destination<SettingsGraph>\n@Composable\nfun MainSettingsScreen(\n    settingsViewModel: SettingsViewModel\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["As well as all Destinations can also declare a ",(0,o.jsx)(n.code,{children:"activityViewModel: ActivityViewModel"}),"."]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["The example uses ",(0,o.jsx)(n.code,{children:"hiltViewModel"}),", but check the next sections if you don't use Hilt."]})}),"\n",(0,o.jsx)(n.h2,{id:"make-your-one-liner-viewmodel-getter",children:"Make your one liner ViewModel getter"}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["This section is not directly related to Compose Destinations. This would be true and valid even if you were not using Compose Destinations library.",(0,o.jsx)(n.br,{}),"\n","I just felt like this could be helpful as I have seen some confusion around getting a ViewModel tied to the navigation destination."]})}),"\n",(0,o.jsxs)(n.p,{children:["In previous examples, I used the most simple way of getting a view model instance, and that is with ",(0,o.jsx)(n.code,{children:"hiltViewModel()"})," which belongs to Hilt Dependency Injection framework."]}),"\n",(0,o.jsxs)(n.p,{children:["I've seen some confusion in the community where some people believe that you need Hilt to get a ViewModel that is tied to a ",(0,o.jsx)(n.code,{children:"NavBackStackEntry"}),". That is not true at all. The only thing Hilt facilitates is injecting dependencies to that ViewModel at the same time. But with some manual setup, you can make your function."]}),"\n",(0,o.jsx)(n.h3,{id:"manual-or-no-dependency-injection",children:"Manual or no dependency injection"}),"\n",(0,o.jsx)(n.p,{children:"If you're manually setting up dependency injection in your code or you simply are not using dependency injection, you can do this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'@Composable\ninline fun <reified VM : ViewModel> viewModel(\n    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {\n        "No ViewModelStoreOwner was provided via LocalViewModelStoreOwner"\n    },\n    savedStateRegistryOwner: SavedStateRegistryOwner = LocalSavedStateRegistryOwner.current\n): VM {\n    return androidx.lifecycle.viewmodel.compose.viewModel(\n        viewModelStoreOwner = viewModelStoreOwner,\n        factory = ViewModelFactory(\n            owner = savedStateRegistryOwner,\n            defaultArgs = (savedStateRegistryOwner as? NavBackStackEntry)?.arguments,\n             //remove this line if you\'re not using Dependency injection\n            dependencyContainer = [ACCESS YOUR DEPENDENCIES GRAPH HERE SOMEHOW],\n        )\n    )\n}\n\nclass ViewModelFactory(\n    owner: SavedStateRegistryOwner,\n    defaultArgs: Bundle?,\n    //remove this line if you\'re not using Dependency injection\n    private val dependencyContainer: DependencyContainer\n) : AbstractSavedStateViewModelFactory(\n    owner,\n    defaultArgs\n) {\n\n    @Suppress("UNCHECKED_CAST")\n    override fun <T : ViewModel?> create(\n        key: String,\n        modelClass: Class<T>,\n        handle: SavedStateHandle\n    ): T {\n        return when (modelClass) {\n            ProfileViewModel::class.java -> ProfileViewModel(\n                dependencyContainer.getProfileLikeCountUseCase,\n                ProfileScreenDestination.argsFrom(handle)\n            )\n\n            GreetingViewModel::class.java -> GreetingViewModel()\n\n            else -> throw RuntimeException("Unknown view model $modelClass")\n        } as T\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["As seen above, if you want a single function for all viewModel types, then you need a single ",(0,o.jsx)(n.code,{children:"ViewModelFactory"})," that can create all your types of ViewModels. Alternatively, you could have one function for each ViewModel (example: ",(0,o.jsx)(n.code,{children:"profileViewModel()"})," to get ",(0,o.jsx)(n.code,{children:"ProfileViewModel"})," by using a ",(0,o.jsx)(n.code,{children:"ProfileViewModelFactory"}),"):"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'\nclass ProfileViewModel(\n    private val getProfileLikeCountUseCase: GetProfileLikeCountUseCase,\n    private val navArgs: ProfileScreenNavArgs\n): ViewModel(){\n    //...\n}\n\nclass ProfileViewModelFactory(\n    owner: SavedStateRegistryOwner,\n    defaultArgs: Bundle?,\n    private val getProfileLikeCountUseCase: GetProfileLikeCountUseCase\n): AbstractSavedStateViewModelFactory(owner, defaultArgs) {\n\n    @Suppress("UNCHECKED_CAST")\n    override fun <T : ViewModel?> create(\n        key: String,\n        modelClass: Class<T>,\n        handle: SavedStateHandle\n    ): T {\n        return ProfileViewModel(\n            getProfileLikeCountUseCase,\n            ProfileScreenDestination.argsFrom(handle)\n        ) as T\n    }\n}\n\n@Composable\nfun profileViewModel(\n    savedStateRegistryOwner: SavedStateRegistryOwner = LocalSavedStateRegistryOwner.current\n): ProfileViewModel {\n    val dependencyContainer = [ACCESS YOUR DEPENDENCIES GRAPH HERE SOMEHOW]\n    val factory = ProfileViewModelFactory(\n        owner = savedStateRegistryOwner,\n        defaultArgs = (savedStateRegistryOwner as? NavBackStackEntry)?.arguments,\n        getProfileLikeCountUseCase = dependencyContainer.getProfileLikeCountUseCase\n    )\n    return viewModel(factory = factory)\n}\n\n@Composable\n@Destination<RootGraph>(\n    navArgs = ProfileScreenNavArgs::class\n)\nfun ProfileScreen(\n    viewModel: ProfileViewModel = profileViewModel()\n){\n    Text("Profile Screen")\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This does mean that every time you add a new ViewModel to your code base, you'll have to come here and add that entry to the ",(0,o.jsx)(n.code,{children:"when"})," statement above, or create a single ",(0,o.jsx)(n.code,{children:"ViewModelFactory"})," per ",(0,o.jsx)(n.code,{children:"ViewModel"}),". Nothing is perfect, and this is definitely one reason to make you want to use a Dependency Injection framework like Hilt, so that this is handled for you."]}),"\n",(0,o.jsx)(n.admonition,{title:'"[ACCESS YOUR DEPENDENCIES GRAPH HERE SOMEHOW]"',type:"info",children:(0,o.jsxs)(n.p,{children:["If you're using manual Dependency injection, you must treat this function as you do with accessing your dependencies graph in an Android entry point (Activity, Fragment, etc), i.e, you need to directly access it somehow.",(0,o.jsx)(n.br,{}),"\n","There are plenty of ways to do this depending on where you're saving the dependencies container instance: you could use ",(0,o.jsx)(n.a,{href:"https://developer.android.com/jetpack/compose/compositionlocal",children:"CompositionLocals"})," feature to provide the container, you could access your singleton ",(0,o.jsx)(n.code,{children:"Application"})," instance if you're dependencies are available there, or you could do ",(0,o.jsx)(n.a,{href:"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:hilt/hilt-navigation/src/main/java/androidx/hilt/navigation/HiltNavBackStackEntry.kt",children:"what Hilt does internally"})," which is taking the ",(0,o.jsx)(n.code,{children:"LocalContext.current"})," and trying to get an Activity from that, then you can get the dependency container declared in that Activity."]})}),"\n",(0,o.jsx)(n.h3,{id:"other-di-frameworks",children:"Other DI frameworks"}),"\n",(0,o.jsx)(n.p,{children:"If you're using a DI framework other than Hilt (Koin, f.e) then you need to check that framework's documentation in how you can get an instance of a ViewModel."}),"\n",(0,o.jsxs)(n.p,{children:["Remember that if in your framework you have to explicitly pass something like ",(0,o.jsx)(n.code,{children:"NavBackStackEntry"}),", ",(0,o.jsx)(n.code,{children:"ViewModelStoreOwner"})," or ",(0,o.jsx)(n.code,{children:"SavedStateRegistryOwner"})," then check the above example to see how to get that. You can use them to make your own wrapper calling the framework method."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);