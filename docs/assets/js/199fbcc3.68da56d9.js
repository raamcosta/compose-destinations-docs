"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[2931],{9643:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var o=t(4848),i=t(8453);const a={sidebar_position:1},s="Bottom bar navigation",r={id:"common-use-cases/bottom-bar-navigation",title:"Bottom bar navigation",description:"One of the common cases for Android development is to have a bottom bar to navigate between the main entry point destinations of an application.",source:"@site/versioned_docs/version-1.x/common-use-cases/bottom-bar-navigation.md",sourceDirName:"common-use-cases",slug:"/common-use-cases/bottom-bar-navigation",permalink:"/common-use-cases/bottom-bar-navigation",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/versioned_docs/version-1.x/common-use-cases/bottom-bar-navigation.md",tags:[],version:"1.x",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Code generation configs",permalink:"/codegenconfigs"},next:{title:"Providing ViewModels to your Screens",permalink:"/common-use-cases/providing-viewmodels"}},c={},l=[];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"bottom-bar-navigation",children:"Bottom bar navigation"}),"\n",(0,o.jsx)(n.p,{children:"One of the common cases for Android development is to have a bottom bar to navigate between the main entry point destinations of an application."}),"\n",(0,o.jsx)(n.p,{children:"With Compose Destinations, achieving it is not too different than with normal Jetpack Compose Navigation, you just have some new tools to make it easier."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Firstly, you need some kind of closed set of Destinations that will be a part of that Bottom Navigation bar."}),(0,o.jsx)(n.br,{}),"\n","For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"enum class BottomBarDestination(\n    val direction: DirectionDestinationSpec,\n    val icon: ImageVector,\n    @StringRes val label: Int\n) {\n    Greeting(GreetingScreenDestination, Icons.Default.Home, R.string.greeting_screen),\n    Feed(FeedScreenDestination, Icons.Default.Email, R.string.feed_screen),\n}\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.p,{children:"You can also use a sealed class, sealed interface, whatever you like. The reasons I personally like enum in this case are:"}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Enums have a ",(0,o.jsx)(n.code,{children:"values()"})," function which comes in handy to populate the bottom bar Composable (as we'll see next)."]}),"\n",(0,o.jsx)(n.li,{children:"All entries of this closed set probably have the exact same properties/functions so there is really no benefit in using sealed class over it."}),"\n"]})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Secondly, create your bottom bar Composable."}),(0,o.jsx)(n.br,{}),"\n","Taking the example from above, that could look something like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun BottomBar(\n    // you can get one `DestinationsNavigator` by calling `navController.toDestinationsNavigator()\n    // or navController.rememberDestinationsNavigator() when in a Composable function`\n    destinationsNavigator: DestinationsNavigator\n) {\n    val currentDestination: Destination? = navController.appCurrentDestinationAsState().value\n        ?: NavGraphs.root.startAppDestination\n\n    BottomNavigation {\n        BottomBarDestination.values().forEach { destination ->\n            BottomNavigationItem(\n                selected = currentDestination == destination.direction,\n                onClick = {\n                    destinationsNavigator.navigate(destination.direction) {\n                        launchSingleTop = true\n                    }\n                },\n                icon = { Icon(destination.icon, contentDescription = stringResource(destination.label))},\n                label = { Text(stringResource(destination.label)) },\n            )\n        }\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["The above ",(0,o.jsx)(n.code,{children:"appCurrentDestinationAsState()"}),' is just a handy generated extension function when in "singlemodule" mode (read about configurations ',(0,o.jsx)(n.a,{href:"../codegenconfigs",children:"here"}),") that returns a Compose State of the current ",(0,o.jsx)(n.code,{children:"Destination"})," equivalent to ",(0,o.jsx)(n.code,{children:"NavController.currentDestinationAsState()"})," of the core library except that it returns the sealed version of ",(0,o.jsx)(n.code,{children:"DestinationSpec"}),".",(0,o.jsx)(n.br,{}),"\n","Same for ",(0,o.jsx)(n.code,{children:"startAppDestination"}),' (generated in "singlemodule" mode) vs ',(0,o.jsx)(n.code,{children:"startDestination"})," (core library)."]}),(0,o.jsx)(n.p,{children:"Given the nature of Compose State, it initally is null so we just consider our start destination when that is the case."})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["Finally, use the Composable on your Scaffold's ",(0,o.jsx)(n.code,{children:"bottomBar"})," slot"]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val navController = rememberNavController()\n\nScaffold(\n    bottomBar = { \n        BottomBar(navController)\n    }\n    //...\n) {\n    DestinationsNavHost(\n        navController = navController //!! this is important\n        // ...\n    )\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Some considerations:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["You could make it so your ",(0,o.jsx)(n.code,{children:"BottomBar"})," Composable only receives the current destination and a lambda to be used when an item gets clicked. This makes your bottom bar more testable and separated from navigation code."]}),"\n",(0,o.jsxs)(n.li,{children:["If each of your bottom bar items corresponds to different navigation graphs, your ",(0,o.jsx)(n.code,{children:"BottomBarDestination"})," enum could contain ",(0,o.jsx)(n.code,{children:"NavGraphSpec"}),"s instead of ",(0,o.jsx)(n.code,{children:"DirectionDestinationSpec"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:['The actual code to navigate can use save and restore states to implement this in a "multi nav back stack" way (read more in ',(0,o.jsx)(n.a,{href:"https://medium.com/androiddevelopers/multiple-back-stacks-b714d974f134",children:"official article"})," or see an example of it in the ",(0,o.jsx)(n.a,{href:"https://github.com/raamcosta/compose-destinations/blob/main/sample/src/main/java/com/ramcosta/destinations/sample/ui/composables/BottomBar.kt",children:"sample app"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["Keep in mind that if at any time you need to fallback to using Jetpack Compose Navigation APIs, you can always just get the route by ",(0,o.jsx)(n.code,{children:"DestinationSpec.route"}),". So all approaches you might find out there, can always be implemented with Compose Destinations as well."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(6540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);