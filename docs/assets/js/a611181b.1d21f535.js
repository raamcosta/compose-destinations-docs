"use strict";(self.webpackChunkcompose_destinations_docs=self.webpackChunkcompose_destinations_docs||[]).push([[622],{4892:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=a(4848),t=a(8453);const o={sidebar_position:6},i="Navigation Host Composables",r={id:"navhosts",title:"Navigation Host Composables",description:"Navigation Host Composables work as the holder for your screens and it's where they will be displayed.",source:"@site/docs/navhosts.md",sourceDirName:".",slug:"/navhosts",permalink:"/v2/navhosts",draft:!1,unlisted:!1,editUrl:"https://github.com/raamcosta/compose-destinations-docs/edit/main/docusaurus/docs/navhosts.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Navigating back with a result",permalink:"/v2/navigation/backresult"},next:{title:"Defining Navigation Graphs",permalink:"/v2/defining-navgraphs"}},l={},d=[{value:"DestinationsNavHost",id:"destinationsnavhost",level:2},{value:"Vanilla NavHosts",id:"vanilla-navhosts",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"navigation-host-composables",children:"Navigation Host Composables"}),"\n",(0,s.jsx)(n.p,{children:"Navigation Host Composables work as the holder for your screens and it's where they will be displayed."}),"\n",(0,s.jsxs)(n.p,{children:["Compose destinations has a recommended way to set up your ",(0,s.jsx)(n.code,{children:"NavHosts"})," and an alternative one. If you are not sure which to use and don't have much experience with Compose Navigation, go with the recommended ",(0,s.jsx)(n.a,{href:"#destinationsnavhost-",children:"DestinationsNavHost"})," way. On the other hand, if you have a lot of experience with vanilla Compose Navigation and just want the type safety of Compose Destinations, you might prefer to use ",(0,s.jsx)(n.a,{href:"#vanilla-navhosts",children:"NavHost"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"destinationsnavhost",children:"DestinationsNavHost"}),"\n",(0,s.jsx)(n.p,{children:'Compose Destinations has a "NavHost-like" Composable that you can use as a base for all your screens.'}),"\n",(0,s.jsxs)(n.p,{children:["It internally calls the Compose Navigation ",(0,s.jsx)(n.code,{children:"NavHost"})," but automatically adds all ",(0,s.jsx)(n.code,{children:"@Destination"})," annotated Composables of a given ",(0,s.jsx)(n.code,{children:"NavGraph"})," instance to the NavHost. When a destination gets navigated to, it calls the corresponding generated ",(0,s.jsx)(n.code,{children:"Content"})," method which prepares the navigation arguments and calls your annotated Composable."]}),"\n",(0,s.jsx)(n.p,{children:"Most times, using it is as simple as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"DestinationsNavHost(navGraph = NavGraphs.root)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"NavGraphs"}),' is a generated object that contains the definition of all your navigation graphs and their destinations. By default, all annotated composable will belong to the "root" navigation graph. But you can customize this however you want. Read more ',(0,s.jsx)(n.a,{href:"defining-navgraphs",children:"here"})]})}),"\n",(0,s.jsx)(n.p,{children:"However, you can override some defaults:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"navGraph: NavGraphSpec"})," - By default ",(0,s.jsx)(n.code,{children:"NavGraphs.root"}),", but it can change depending on your ",(0,s.jsx)(n.a,{href:"defining-navgraphs",children:"navigation graphs setup"}),". Only destinations that belong to this navigation graph or its nested navigation graphs can be navigated to using the ",(0,s.jsx)(n.code,{children:"NavController"})," connected to this navigation host."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"modifier: Modifier"})," - modifier applied to this Composable. It affects the screen Composable."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"startRoute: Route"}),": used to override the start route set in the ",(0,s.jsx)(n.code,{children:"NavGraph"}),' "startRoute" parameter at runtime. If you have some condition upon which you want to start on some other screen, then pass it explicitly with this parameter. ',(0,s.jsx)(n.code,{children:"Route"})," is an interface only implemented by ",(0,s.jsx)(n.code,{children:"Destination"})," and ",(0,s.jsx)(n.code,{children:"NavGraph"}),", since both are valid to start at (if you pass a ",(0,s.jsx)(n.code,{children:"NavGraph"})," then that ",(0,s.jsx)(n.code,{children:"NavGraph"}),"'s start destination will be the first shown)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"engine: NavHostEngine"})," - this is the engine that will do all the composable registering in the NavHost. The only reason to override the default here is when you're using ",(0,s.jsx)(n.code,{children:"animations-core"}),", i.e, when you want to animate between screens or have Bottom Sheet destinations. If that is your case, then call ",(0,s.jsx)(n.code,{children:"rememberAnimatedNavHostEngine"})," and pass the result here. Read more ",(0,s.jsx)(n.a,{href:"styles-and-animations",children:"here"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"navController: NavHostController"}),": If you need to get a hold of the ",(0,s.jsx)(n.code,{children:"NavController"}),", you can use ",(0,s.jsx)(n.code,{children:"rememberAnimatedNavController"})," if you're using ",(0,s.jsx)(n.code,{children:"animations-core"})," and the normal ",(0,s.jsx)(n.code,{children:"rememberNavController"})," if you are not."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dependenciesContainerBuilder"})," offers a ",(0,s.jsx)(n.code,{children:"DependenciesContainerBuilder"})," where you can add dependencies by their class via ",(0,s.jsx)(n.code,{children:"com.ramcosta.composedestinations.navigation.dependency()"}),". The lambda will be called when a Composable screen gets navigated to and ",(0,s.jsx)(n.code,{children:"DependenciesContainerBuilder"})," also implements ",(0,s.jsx)(n.code,{children:"com.ramcosta.composedestinations.manualcomposablecalls.DestinationScope"})," so you can access all information about what ",(0,s.jsx)(n.code,{children:"DestinationSpec"})," is being navigated to. Read more ",(0,s.jsx)(n.a,{href:"arguments/nav-host-parameters#use-dependenciescontainerbuilder-to-prepare-dependencies",children:"here"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"manualComposableCallsBuilder: ManualComposableCallsBuilder.() -> Unit"}),": offers a ",(0,s.jsx)(n.code,{children:"ManualComposableCallsBuilder"})," scope where you can\nmake manual calls to specific Destination Composables which belong to the ",(0,s.jsx)(n.code,{children:"navGraph"})," passed in here. This can be useful if you need to pass non-navigation arguments to those specific Composables which the library cannot provide. Read more ",(0,s.jsx)(n.a,{href:"arguments/nav-host-parameters",children:"here"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"vanilla-navhosts",children:"Vanilla NavHosts"}),"\n",(0,s.jsxs)(n.p,{children:["If you are experienced with using Compose Navigation, you may prefer using the same NavHost Composable.",(0,s.jsx)(n.br,{}),"\n","In that case, navigation graphs are defined with Kotlin DSL, and so there's no point in Compose Destinations also generating them.",(0,s.jsx)(n.br,{}),"\n","To disable nav graph generation, do:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gradle",children:'ksp {\n    arg("compose-destinations.generateNavGraphs", "false")\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If doing this, Compose Destinations will not be able to be as helpful at compile time as it is otherwise.\nFor example, it won't generate mermaid visual graphs. (read about that ",(0,s.jsx)(n.a,{href:"defining-navgraphs#visualisation-and-documentation",children:"here"}),")"]}),"\n",(0,s.jsxs)(n.p,{children:["That said, ",(0,s.jsx)(n.code,{children:"Destination"}),"s are still very nice to use with the vanilla NavHosts. There are extension functions on ",(0,s.jsx)(n.code,{children:"NavGraphBuilder"})," that will let you register those destinations in a type-safe way and with much less boilerplate.\nHere's an example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"NavHost(\n    navController = navController,\n    startDestination = GreetingScreenDestination.route,\n) {\n    composable(SomeScreenDestination) { // this: NavGraphBuilderDestinationScope<SomeScreenDestination.NavArgs>\n        SomeScreen(\n            arg1 = navArgs.arg1,\n            arg2 = navArgs.arg2,\n            navigator = destinationsNavigator(navController),\n            resultRecipient = resultRecipient(),\n            resultBackNavigator = resultBackNavigator(navController)\n        )\n    }\n\n    // Use `dialogComposable` if the destination has a `style = DestinationStyle.Dialog::class` or subclass\n\n    // Use `bottomSheetComposable` if the destination has a `style = DestinationStyleBottomSheet::class`\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>r});var s=a(6540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);